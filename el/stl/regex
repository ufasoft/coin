/*######     Copyright (c) 1997-2013 Ufasoft  http://ufasoft.com  mailto:support@ufasoft.com,  Sergey Pavlov  mailto:dev@ufasoft.com #######################################
#                                                                                                                                                                          #
# This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation;  #
# either version 3, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the      #
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU #
# General Public License along with this program; If not, see <http://www.gnu.org/licenses/>                                                                               #
##########################################################################################################################################################################*/

#pragma once

#define _REGEX_

namespace ExtSTL {
class StdRegexObj;
}

namespace Ext {
template <> struct ptr_traits<ExtSTL::StdRegexObj> {
	typedef Ext::Interlocked interlocked_policy;
};
}

namespace ExtSTL {

#if !UCFG_CPP11_HAVE_REGEX
	using namespace std;
#endif

	namespace regex_constants {

 #define _REGEX_BITMASK_OPS(Ty) \
inline Ty& operator&=(Ty& _Left, Ty _Right) \
	{	/* return _Left &= _Right */ \
	_Left = (Ty)((int)_Left & (int)_Right); return (_Left); \
	} \
\
inline Ty& operator|=(Ty& _Left, Ty _Right) \
	{	/* return _Left |= _Right */ \
	_Left = (Ty)((int)_Left | (int)_Right); return (_Left); \
	} \
\
inline Ty& operator^=(Ty& _Left, Ty _Right) \
	{	/* return _Left ^= _Right */ \
	_Left = (Ty)((int)_Left ^ (int)_Right); return (_Left); \
	} \
\
inline Ty operator&(Ty _Left, Ty _Right) \
	{	/* return _Left & _Right */ \
	return ((Ty)((int)_Left & (int)_Right)); \
	} \
\
inline Ty operator|(Ty _Left, Ty _Right) \
	{	/* return _Left | _Right */ \
	return ((Ty)((int)_Left | (int)_Right)); \
	} \
\
inline Ty operator^(Ty _Left, Ty _Right) \
	{	/* return _Left ^ _Right */ \
	return ((Ty)((int)_Left ^ (int)_Right)); \
	} \
\
inline Ty operator~(Ty _Left) \
	{	/* return ~_Left */ \
	return ((Ty)~(int)_Left); \
	}


enum syntax_option_type {
	ECMAScript = 0x01,
	basic = 0x02,
	extended = 0x04,
	awk = 0x08,
	grep = 0x10,
	egrep = 0x20,
	_Gmask = 0x3F,

	icase = 0x0100,
	nosubs = 0x0200,
	optimize = 0x0400,
	collate = 0x0800
};
_REGEX_BITMASK_OPS(syntax_option_type)

enum match_flag_type {
	match_default = 0x0000,
	match_not_bol = 0x0001,
	match_not_eol = 0x0002,
	match_not_bow = 0x0004,
	match_not_eow = 0x0008,
	match_any = 0x0010,
	match_not_null = 0x0020,
	match_continuous = 0x0040,
	_Match_partial = 0x0080,
	match_prev_avail = 0x0100,
	format_default = 0x0000,
	format_sed = 0x0400,
	format_no_copy = 0x0800,
	format_first_only = 0x1000,
	_Match_not_null = 0x2000
};
_REGEX_BITMASK_OPS(match_flag_type)

enum error_type {
	error_collate,
	error_ctype,
	error_escape,
	error_backref,
	error_brack,
	error_paren,
	error_brace,
	error_badbrace,
	error_range,
	error_space,
	error_badrepeat,
	error_complexity,
	error_stack,
};

} // regex_constants::

class regex_error : public runtime_error {
public:
	explicit regex_error(regex_constants::error_type)
		:	runtime_error("regex error")
	{}
};

class basic_regexBase : protected Ext::Pimpl<StdRegexObj> {
public:
	typedef regex_constants::syntax_option_type flag_type;

	static const flag_type icase = regex_constants::icase;
	static const flag_type nosubs = regex_constants::nosubs;
	static const flag_type optimize = regex_constants::optimize;
	static const flag_type collate = regex_constants::collate;
	static const flag_type ECMAScript = regex_constants::ECMAScript;
	static const flag_type basic = regex_constants::basic;
	static const flag_type extended = regex_constants::extended;
	static const flag_type awk = regex_constants::awk;
	static const flag_type grep = regex_constants::grep;
	static const flag_type egrep = regex_constants::egrep;

	void *Re() const;
	void *FullRe() const;
protected:
	~basic_regexBase();
};

template <typename EL>
class basic_regex {
};

template <> class basic_regex<char> : public basic_regexBase {
public:
	basic_regex<char>(Ext::RCString pattern, flag_type flags = ECMAScript);
};

template <> class basic_regex<wchar_t> : public basic_regexBase {
public:
	basic_regex<wchar_t>(Ext::RCString pattern, flag_type flags = ECMAScript);
};

template <typename I>
class sub_match : public pair<I, I> {
public:
	typedef typename iterator_traits<I>::value_type value_type;
	typedef size_t difference_type;
	typedef I iterator;
	typedef basic_string<value_type> string_type;
	
	Ext::CBool matched;

	difference_type length() const {
		return matched ? distance(this->first, this->second) : 0;
	}

	string_type str() const {
		return matched ? string_type(this->first, this->second) : string_type();
	}

	operator string_type() const { return str(); }

	int compare(const value_type *p) const { return str().compare(p); }
	int compare(const string_type& x) const { return str().compare(x); }
	int compare(const sub_match& x) const { return compare(x.str()); }

	bool operator==(const sub_match& sm) const { return !compare(sm); }
	bool operator!=(const sub_match& sm) const { return !operator==(sm); }
};

template <typename I, class A = std::allocator<sub_match<I>> >
class match_results : protected vector<sub_match<I>> {
	typedef vector<sub_match<I>> base;
public:
	typedef sub_match<I> value_type;
	typedef const value_type& const_reference;
	typedef typename iterator_traits<I>::value_type char_type;
	typedef basic_string<char_type> string_type;
	typedef A allocator_type;

	using base::empty;
	using base::size;
	using base::begin;
	using base::end;

	match_results()
		:	m_null()
	{
	}

	bool ready() const { return m_ready; }

	const_reference operator[](size_t idx) const {
		return idx < size() ? base::operator[](idx) : m_null;
	}

	const_reference prefix() const { return m_prefix; }
	const_reference suffix() const { return m_suffix; }

	size_t length(int idx = 0) const { return operator[](idx).length(); }	
	size_t position(int idx = 0) const { return distance(m_org, operator[](idx).first); }
	string_type str(int idx = 0) const { return operator[](idx).str(); }

	const value_type m_null;
	value_type m_prefix;
	value_type m_suffix;
	I m_org;
	Ext::CBool m_ready;

	//!!! Should be Private
	value_type& GetSubMatch(int idx) {
		return base::operator[](idx);
	}

	void Resize(size_t size) {
		base::resize(size);
	}
};

typedef match_results<const char *> cmatch;
typedef match_results<const wchar_t *> wcmatch;
typedef match_results<string::const_iterator> smatch;
typedef match_results<wstring::const_iterator> wsmatch;

template <typename I, typename EL>
bool regex_searchImpl(I b, I e, match_results<I> *m, StdRegexObj& re, regex_constants::match_flag_type flags, I org);

EXT_API bool AFXAPI regex_searchImpl(const char *b, const char *e, match_results<const char*> *m, const basic_regexBase& re, bool bMatch, regex_constants::match_flag_type flags, const char *org);
EXT_API bool AFXAPI regex_searchImpl(const wchar_t *b, const wchar_t *e, match_results<const wchar_t*> *m, const basic_regexBase& re, bool bMatch, regex_constants::match_flag_type flags, const wchar_t *org);
EXT_API bool AFXAPI regex_searchImpl(string::const_iterator bi,  string::const_iterator ei, smatch *m, const basic_regexBase& re, bool bMatch, regex_constants::match_flag_type flags, string::const_iterator orgi);

template <typename I, typename A, typename EL>	bool regex_search(I b, I e, match_results<I, A>& m,												const basic_regex<EL>& re, regex_constants::match_flag_type flags = regex_constants::match_default) { return regex_searchImpl(b, e,								&m,	re, false, flags,									b); }
template <typename I, typename EL>	bool regex_search(I b, I e,																					const basic_regex<EL>& re, regex_constants::match_flag_type flags = regex_constants::match_default)	{ return regex_searchImpl(b, e,								0,	re, false, flags | regex_constants::match_any,	b); }
template <typename EL, typename A>	bool regex_search(const EL *p, match_results<const EL*, A>& m,												const basic_regex<EL>& re, regex_constants::match_flag_type flags = regex_constants::match_default)	{ return regex_searchImpl(p, p+char_traits<EL>::length(p),	&m,	re, false, flags,									p); }
template <typename EL>				bool regex_search(const EL *p,																				const basic_regex<EL>& re, regex_constants::match_flag_type flags = regex_constants::match_default)	{ return regex_searchImpl(p, p+char_traits<EL>::length(p),	0,	re, false, flags | regex_constants::match_any,	p); }
template <typename EL, typename A>	bool regex_search(const basic_string<EL>& s, match_results<typename basic_string<EL>::const_iterator, A>& m,const basic_regex<EL>& re, regex_constants::match_flag_type flags = regex_constants::match_default)	{ return regex_searchImpl(s.begin(), s.end(),				&m,	re, false, flags,									s.begin()); }
template <typename EL>				bool regex_search(const basic_string<EL>& s,																const basic_regex<EL>& re, regex_constants::match_flag_type flags = regex_constants::match_default)	{ return regex_searchImpl(s.begin(), s.end(),				0,	re, false, flags | regex_constants::match_any,	s.begin()); }


/*!!!R
template <typename I, typename EL>
bool regex_matchImpl(I b, I e, match_results<I> *m, const basic_regex<EL>& re, regex_constants::match_flag_type flags);

bool AFXAPI regex_matchImpl(const char *b, const char *e, match_results<const char*> *m, StdRegexObj& re, regex_constants::match_flag_type flags);
bool AFXAPI regex_matchImpl(const wchar_t *b, const wchar_t *e, match_results<const wchar_t*> *m, StdRegexObj& re, regex_constants::match_flag_type flags);
*/

template <typename I, typename A, typename EL>	bool regex_match(I b, I e, match_results<I, A>& m,												const basic_regex<EL>& re, regex_constants::match_flag_type flags = regex_constants::match_default) { return regex_searchImpl(b, e,								&m,	re, true, flags,									b); }
template <typename I, typename EL>	bool regex_match(I b, I e,																					const basic_regex<EL>& re, regex_constants::match_flag_type flags = regex_constants::match_default)	{ return regex_searchImpl(b, e,								0,	re, true, flags | regex_constants::match_any,	b); }
template <typename EL, typename A>	bool regex_match(const EL *p, match_results<const EL*, A>& m,												const basic_regex<EL>& re, regex_constants::match_flag_type flags = regex_constants::match_default)	{ return regex_searchImpl(p, p+char_traits<EL>::length(p),	&m,	re, true, flags,									p); }
template <typename EL>				bool regex_match(const EL *p,																				const basic_regex<EL>& re, regex_constants::match_flag_type flags = regex_constants::match_default)	{ return regex_searchImpl(p, p+char_traits<EL>::length(p),	0,	re, true, flags | regex_constants::match_any,	p); }
template <typename EL, typename A>	bool regex_match(const basic_string<EL>& s, match_results<typename basic_string<EL>::const_iterator, A>& m,	const basic_regex<EL>& re, regex_constants::match_flag_type flags = regex_constants::match_default)	{ return regex_searchImpl(s.begin(), s.end(),				&m,	re, true, flags,									s.begin()); }
template <typename EL>				bool regex_match(const basic_string<EL>& s,																	const basic_regex<EL>& re, regex_constants::match_flag_type flags = regex_constants::match_default)	{ return regex_searchImpl(s.begin(), s.end(),				0,	re, true, flags | regex_constants::match_any,	s.begin()); }



template <typename OI, typename I, typename EL>
OI regex_replaceImpl(OI oi, I b, I e, const basic_regex<EL>& re, const basic_string<EL>& fmt, regex_constants::match_flag_type flags);


template <typename OI, typename I, typename EL>	OI	regex_replace(OI oi, I b, I e,				const basic_regex<EL>& re, const basic_string<EL>& fmt,	regex_constants::match_flag_type flags = regex_constants::match_default) { return regex_replaceImpl(oi, b, e, re, fmt,	flags); }
template <typename OI, typename I, typename EL>	OI	regex_replace(OI oi, I b, I e,				const basic_regex<EL>& re, const EL *p,					regex_constants::match_flag_type flags = regex_constants::match_default) { return regex_replaceImpl(oi, b, e, re, p,	flags); }

template <typename EL> 	basic_string<EL> regex_replace(const basic_string<EL>& s,	const basic_regex<EL>& re, const basic_string<EL>& fmt,	regex_constants::match_flag_type flags = regex_constants::match_default) { basic_string<EL> r; regex_replaceImpl(back_inserter(r), s.begin(), s.end(), re, fmt,	flags); return r; }
EXT_API string AFXAPI regex_replace(const string& s, const basic_regex<char>& re, const string& fmt, regex_constants::match_flag_type flags = regex_constants::match_default);

template <typename EL>			basic_string<EL>	regex_replace(const basic_string<EL>& s,	const basic_regex<EL>& re, const EL *p,					regex_constants::match_flag_type flags = regex_constants::match_default) { return regex_replace(s, re, basic_string<EL>(p), flags); }
template <typename EL>			basic_string<EL>	regex_replace(const EL *ps,					const basic_regex<EL>& re, const basic_string<EL>& fmt,	regex_constants::match_flag_type flags = regex_constants::match_default) { return regex_replace(ps, re, fmt, flags); }
template <typename EL>			basic_string<EL>	regex_replace(const EL *ps,					const basic_regex<EL>& re, const EL *p,					regex_constants::match_flag_type flags = regex_constants::match_default) { return regex_replace(ps, re, p, flags); }


template <typename I>
class regex_iterator {
public:
	typedef basic_regex<typename iterator_traits<I>::value_type> regex_type;
	typedef match_results<I> value_type;
	typedef ptrdiff_t difference_type;
	typedef const value_type *pointer;
	typedef const value_type& reference;
	typedef forward_iterator_tag iterator_category;

	regex_iterator()
		:	m_pRe(0)
		,	m_b()
		,	m_e()
	{}

	regex_iterator(I b, I e, const regex_type& re, regex_constants::match_flag_type flags = regex_constants::match_default)
		:	m_b(b), m_e(e), m_pRe(&re), m_flags(flags)
	{
		if (!regex_search(m_b, m_e, m_m, *m_pRe, m_flags))
			m_pRe = 0;
	}

	bool operator==(const regex_iterator& it) const {
		return (m_pRe == it.m_pRe) && (!m_pRe || m_b==it.m_b && m_e==it.m_e && m_flags==it.m_flags && m_m[0] == it.m_m[0]);
	}

	bool operator!=(const regex_iterator& it) const { return !operator==(it); }

	const value_type& operator*() { return m_m; }
	pointer operator->() const { return &m_m; }

	regex_iterator& operator++() {
		if (m_pRe) {
			I b = m_m[0].second;
			if (m_m[0].first == b) {		// zero-match
				if (b == m_e)
					m_pRe = 0;
				else if (!regex_searchImpl(b, m_e, &m_m, *m_pRe, false, m_flags | regex_constants::match_not_null | regex_constants::match_continuous, m_b))
					++b;
			}
			if (!regex_searchImpl(b, m_e, &m_m, *m_pRe, false, m_flags |= regex_constants::match_prev_avail, m_b))
				m_pRe = 0;
		}
		return *this;
	}

	regex_iterator operator++(int) {
		regex_iterator r = *this;
		operator++();
		return r;
	}
private:
	const I m_b, m_e;
	value_type m_m;
	const regex_type *m_pRe;
	regex_constants::match_flag_type m_flags;
};




typedef basic_regex<char> regex;
typedef basic_regex<wchar_t> wregex;

typedef sub_match<const char *> csub_match;
typedef sub_match<const wchar_t *> wcsub_match;
typedef sub_match<string::const_iterator> ssub_match;
typedef sub_match<wstring::const_iterator> wssub_match;


typedef regex_iterator<const char *> cregex_iterator;
typedef regex_iterator<const wchar_t *> wcregex_iterator;
typedef regex_iterator<string::const_iterator> sregex_iterator;
typedef regex_iterator<wstring::const_iterator> wsregex_iterator;


} // ExtSTL::

